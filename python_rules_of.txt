Если предметная область сложная, то создаются сущности предметной области (которые маппятся
на таблицы в слое адаптеров). В сущностях описывается их поведение и инварианты.



Если предметная область простая (например, строим простые графики), то достаточно описать data
transfer objects (DTO) и возвращать их из репозиториев/шлюзов/api клиентов в первичных адаптерах.
Простые структуры данных (словари, списки скалярных значений, списки словарей) между слоями
передаваться не должны. DTO это обычные датаклассы с простейшим поведением.

у нас используется как можно меньше диалекто-зависимых конструкций, а если используется, то
помечается как # TODO: dialect dependent


Таблицы описаны в виде обычных таблиц sqlalchemy, указывать naming_convention в Metadata
обязательно. Если планируется использовать MSSQL, то указывается схема "app", так же в
env.py алембика делаются изменения

названия таблиц начинаются с маленьких букв, используется snake_case. Таблицы-сущности и
справочники именуются во множественном числе, всяческие таблицы-логи в единственном числе
если в проекте сложная доменная логика, то создается маппер таблиц на классы с бизнес-
логикой через императивный маппинг sqlalchemy (тут важно следить за связанными сущностями
для избегания проблемы N+1)
весь код запросов пишется в репозиториях. Бизнес логика не зашивается в запросы и слой
адаптеров
в сложном проекте из репозиториев возвращаются намапленные ORM объекты, в простом
случае DTO (data transfer object)

Сериализация:
- Decimal - строка
- datetime - isoformat (см. "Работа с датой (timezone)")
- time - isoformat
- UUID - строка
- Enum - тут либо name, либо value, в зависимости от потребностей

Клиенты не должны знать технические детали ошибок.
Для этого все ошибки приложения описаны в слое бизнес логики. Так же есть валидация в сервисах.
Ошибки из СУБД мы не используем, они слишком обобщенные. Для этого сервис может проверить
некоторые условия и возбудить ошибку из своего слоя.

В БД приложения все время хранится в UTC, на фронт тоже уходит UTС, на беке расчеты тоже
происходят по UTC, фронт уже сам решит что с этим делать. У нас БД MS-SQL, принято решение, что все даты мы должны хранить в naive utc виде, в поле типа
datetime (нет возможности хранения тайм-зоны)  на фронт дата должна уходить с указанием
тайм зоны 

print не используется в основных ветках проекта!
Используется стандартный модуль logging настройки хранятся в каждом settings.py. Используется такой формат:
fmt = '%(asctime)s.%(msecs)03d [%(levelname)s]|[%(name)s]: %(message)s'
datefmt = '%Y-%m-%d %H:%M:%S

Неверно:
id_ = 1
self.logger.info(f'Transport with id [{id_}] was deleted')
Верно:
id_ = 1
self.logger.info('Transport with id [%s] was deleted', id_)

При многочисленных DEBUG логах на ландшафте с уровнем INFO мы не скушаем кучу
процессорного времени на форматирование строк. Наша инфраструктура собирает логи, для этого
нужно их писать в JSON формате. Для этого используется пакет python-json-logger. JSON формат в
наших проектах опционален, настраивается через settings.py


Прочие технические детали:
Транзакции СУБД
У нас нет вложенных транзакций. У нас используется что-то типа паттерна "Единица работы".
"Единица работы" в наших внутренних библиотеках работает как декоратор над методом
контроллера И/ИЛИ над публичным методом сервиса. "Единица работы" открывает транзакцию перед
выполнением основного кода, закрывает после, отслеживает попытки создать внутренние транзакции
и мешает этому. В коде не должно быть ручного управления транзакциями.

Асинхронный код
Чтобы использовать асинхронные решения нужно это обосновать. У нас очень мало
нагруженных приложений, которые действительно упираются в IO. Если очень нужно, то используем
gevent, просто патчим код в начале запуска. Отдельно надо патчить mssql драйвер.

Зависимости DS
Такие библиотеки как pandas, numpy используем в DS модулях (feature engineering и тд.), вне этих
модулей не используется.

Websockets
Вебсокеты строятся при необходимости получать на фронте push уведомления. Используется
Rabbitmq с плагином Stomp over ws

Авторизация
Наш фронт ходит в keycloak и получает токен, этот токен является JWT токеном и расшифровывается
стандартными средствами, мы используем пакет pyjwt. В токене находится вся информация о
пользователе. Токен передается как bearer в стандартном заголовке Authorization (пример:
Authorization: Bearer ...). Приложение принимает решение на основе данных из токена. У нас есть
класс "Аутентификатор", который этим занимается, он внедряет в контроллер инфу о пользователе.
Контроллер принимает решения об авторизации.